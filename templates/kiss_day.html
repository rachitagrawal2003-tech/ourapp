{% extends 'base.html' %}

{% block title %}Kiss Day - Feb 13{% endblock %}

{% block extra_css %}
<style>
    canvas {
        touch-action: none;
        cursor: crosshair;
    }
</style>
{% endblock %}

{% block content %}
<div class="flex flex-col items-center justify-center w-full px-4">

    <div class="text-center mb-8">
        <h1 class="text-4xl md:text-6xl font-dancing text-valentine-800 dark:text-valentine-200 mb-2">
            Kiss Day
        </h1>
        <p class="text-gray-600 dark:text-gray-400 italic">
            Wipe the mirror to see a surprise...
        </p>
    </div>

    <!-- Mirror Container -->
    <div
        class="relative w-full max-w-lg aspect-[3/4] md:aspect-square rounded-2xl overflow-hidden shadow-2xl border-8 border-gray-300 dark:border-gray-700 bg-gray-100">
        <!-- Hidden Image -->
        <img src="/assets/kiss.jpg" alt="Kiss" class="absolute inset-0 w-full h-full object-cover">

        <!-- Fog Canvas -->
        <canvas id="fog-canvas" class="absolute inset-0 w-full h-full z-10 opacity-95"></canvas>
    </div>

</div>

<script>
    const canvas = document.getElementById('fog-canvas');
    const ctx = canvas.getContext('2d');
    let isDrawing = false;

    function initCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        fillFog();
    }

    function fillFog() {
        ctx.fillStyle = '#e5e7eb'; // Gray-200 approx
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Add some "condensation" droplets visuals
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = '#d1d5db';
        for (let i = 0; i < 500; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const r = Math.random() * 2;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Reset for erasing
        ctx.globalCompositeOperation = 'destination-out';
    }

    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.changedTouches) {
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function wipe(e) {
        if (!isDrawing) return;
        e.preventDefault();

        const pos = getPos(e);
        const radius = 30; // Brush size

        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        ctx.fill();

        // "Drip" effect? Maybe too complex for now. Simple wipe is clean.
    }

    canvas.addEventListener('mousedown', (e) => { isDrawing = true; wipe(e); });
    canvas.addEventListener('mousemove', wipe);
    window.addEventListener('mouseup', () => isDrawing = false);

    canvas.addEventListener('touchstart', (e) => { isDrawing = true; wipe(e); }, { passive: false });
    canvas.addEventListener('touchmove', wipe, { passive: false });
    window.addEventListener('touchend', () => isDrawing = false);

    // Initial Setup
    window.onload = initCanvas;
    window.addEventListener('resize', () => {
        // Debounce? For now just re-init might clear progress, which mimics "fog coming back"
        // But maybe users want to keep it clear.
        // Let's not reset on resize to be safe, just CSS scale handles it.
        // If we must:
        // initCanvas();
    });

    // Auto-fill on start
    setTimeout(initCanvas, 100);

</script>
{% endblock %}